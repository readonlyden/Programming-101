---
title: 2. Условные операторы. Операторы циклов. Функции и рекурсия. Массивы.
summary: Условные операторы. Операторы циклов. Функции и рекурсия. Массивы.
authors:
    - Оболенский Д.М.
---

## Условные операторы
Условные операторы позволяют направить работу программы по одному из путей в зависимости от определенных условий.

В языке *Java* используются следующие условные операторы: 

* `if/else`
* `switch/case`

### Оператор __if__
Оператор `if` проверяет истинность некоторого условия и в зависимости от результатов проверки выполняет определенный код.
После ключевого слова `if` ставится *условие*. И если это условие выполняется, то срабатывает код, который помещен в далее в блоке `if` после фигурных скобок: 
```java
int num1 = 10;
int num2 = 4;
if (num1 > num2) {
    System.out.println("Первое число больше второго");
}
```

Например, в данном случае первое число больше второго, то выражение `num1 > num2` истинно и возвращает значение `true`. Следовательно, управление переходит в блок кода после фигурных скобок и начинает выполнять содержащиеся там инструкции, а конкретно метод `System.out.println("Первое число больше второго")`;. Если бы первое число оказалось бы меньше второго или равно ему, то инструкции в блоке `if` не выполнялись бы вообще.

### Оператор __if/else__
Оператор `if/else` проверяет истинность некоторого условия и в зависимости от результатов проверки выполняет либо один блок кода, либо другой блок кода. В этом случае можно добавить блок `else`:
```java
int num1 = 6;
int num2 = 4;
if (num1 > num2) {
    System.out.println("Первое число больше второго");
}
else {
    System.out.println("Первое число меньше второго");
}
```

При сравнении чисел мы можем насчитать три состояния: первое число больше второго, первое число меньше второго и числа равны. Дополнительные условия можно обрабатывать при помощи вложенных операторов `if/else`:
```java
int num1 = 6;
int num2 = 8;
if (num1 > num2) {
    System.out.println("Первое число больше второго");
}
else if(num1 < num2) {
    System.out.println("Первое число меньше второго");
}
else {
    System.out.println("Числа равны");
}
```

Данный код эквивалентен следующему коду:
```java
int num1 = 6;
int num2 = 8;
if (num1 > num2) {
    System.out.println("Первое число больше второго");
}
else {
    if(num1 < num2) {
        System.out.println("Первое число меньше второго");
    }
    else {
        System.out.println("Числа равны");
    }
}
```

Используя логические операторы, можно соединить несколько условий:
```java
int num1 = 8;
int num2 = 6;
if (num1 > num2 && num1 > 7) {
    System.out.println("Первое число больше второго и больше 7");
}
```

Здесь блок `if` будет выполняться, если `num1 > num2` равно `true` и одновременно `num1 > 7` равно `true`.

### Оператор __switch/case__
Оператор `switch/case` аналогичен оператору `if/else`, так как позволяет обработать сразу несколько условий. 
После ключевого слова `switch` в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями, помещенными после операторов `сase`. И если совпадение найдено, то будет выполняет соответствующий блок `сase`.
В конце блока сase ставится оператор break, чтобы избежать выполнения других блоков.

```java
int num = 8;
switch (num) {       
    case 1: 
        System.out.println("число равно 1");
        break;
    case 8: 
        System.out.println("число равно 8");
        num++;
        break;
    case 9: 
        System.out.println("число равно 9");
        break;
    default:
        System.out.println("число не равно 1, 8, 9");
}
```

Если убрать оператор `break` в следующем случае, то выполнится блок `case 8`, (поскольку переменная `num` равна `8`). Но так как в этом блоке оператор `break` отсутствует, то также начнёт выполняться блок `case 9`.
```java
case 8: 
    System.out.println("число равно 8");
    num++;
case 9: 
    System.out.println("число равно 9");
    break;
```

Если мы хотим также обработать ситуацию, когда совпадения не будет найдено, то можно добавить блок `default`. Блок `default` необязателен.

Можно определить одно действие сразу для нескольких блоков case подряд:
```java
int num = 3;
int output = 0;
switch (num) {
    case 1: 
        output = 3;
        break;
    case 2: 
    case 3: 
    case 4: 
        output = 6;
        break;
    case 5: 
        output = 12;
        break;
    default:
        output = 24;
}
System.out.println(output);
```

## Циклы
Еще одним видом управляющих конструкций являются циклы. Циклы позволяют в зависимости от определенных условий выполнять определенное действие множество раз. В языке *Java* есть следующие виды циклов:

* `for`
* `while`
* `do...while`

### Цикл __for__
Цикл `for` имеет следующее формальное определение:
``` java
for ([инициализация счетчика]; [условие]; [изменение счетчика])
{
    // действия
}
```

Рассмотрим стандартный цикл for:
```java
for (int i = 1; i < 9; i++) {
    System.out.printf("Квадрат числа %d равен %d \n", i, i * i);
}
```

Первая часть объявления цикла - `int i = 1` создает и инициализирует счетчик `i`. Счетчик необязательно должен представлять тип `int`. Это может быть и любой другой числовой тип, например, `float`. Перед выполнением цикла значение счетчика будет равно 1. В данном случае это то же самое, что и объявление переменной.

Вторая часть - условие, при котором будет выполняться цикл. В данном случае цикл будет выполняться, пока `i` не достигнет 9.

И третья часть - изменение переменной-счётчика. Например, приращение счетчика на единицу. Опять же нам необязательно увеличивать на единицу. Можно уменьшать: `i--`.

В итоге блок цикла сработает 8 раз, пока значение `i` не станет равным 9. И каждый раз это значение будет увеличиваться на 1.

Все 3 части при объявлении цикла `for` являются *необязательными*. Например, можно написать так:
```java
int i = 1;
for (;;) {
    System.out.printf("Квадрат числа %d равен %d \n", i, i * i);
}
```
Определение цикла осталось тем же, только теперь блоки в определении у нас пустые: `for (;;)`. Теперь нет инициализированной переменной-счетчика, нет условия, поэтому цикл будет работать вечно - бесконечный цикл.

Либо можно опустить ряд блоков:
```java
int i = 1;
for (;i<9;) {
    System.out.printf("Квадрат числа %d равен %d \n", i, i * i);
    i++;
}
```
Этот пример эквивалентен первому примеру: у нас также есть счетчик, только создан он вне цикла. У нас есть условие выполнения цикла. И есть приращение счетчика уже в самом блоке `for`.

Цикл `for` может определять сразу несколько переменных и управлять ими:
```java
int n = 10;
for(int i=0, j = n - 1; i < j; i++, j--){
             
    System.out.println(i * j);
}
```

### Цикл __do__
Цикл `do` сначала выполняет код цикла, а потом проверяет условие в инструкции `while`. И пока это условие истинно, цикл повторяется.
```java
do
{
    // действия
}
while ([условие])
```

Например:
```java
int j = 7;
do {
    System.out.println(j);
    j--;
}
while (j > 0);
```

В данном случае код цикла сработает 7 раз, пока `j` не окажется равным нулю. Важно отметить, что цикл `do` **гарантирует** хотя бы **однократное** выполнение действий, даже если условие в инструкции `while` не будет истинно. Так, мы можем написать:
```java
int j = -1;
do{
    System.out.println(j);
    j--;
}
while (j > 0);
```

Хотя переменная `j` изначально меньше 0, цикл все равно один раз выполнится.

### Цикл __while__
Цикл `while` **сразу** проверяет истинность некоторого условия, и если условие истинно, то код цикла выполняется:
```java
while ([условие]) {
    // действия
}

Например:
```java
int j = 6;
while (j > 0){
 
    System.out.println(j);
    j--;
}
```

### Операторы __continue__ и __break__
Оператор `break` позволяет выйти из цикла **в любой его момент**, даже если цикл не закончил свою работу:

Например:
```java
for (int i = 0; i < 10; i++){
    if (i == 5)
        break;
    System.out.println(i);
}
```

Когда счетчик станет равным 5, сработает оператор `break`, и цикл завершится.

Оператор `continue` используется, если надо не завершать цикл, а просто перейти к следующей итерации:
```java
for (int i = 0; i < 10; i++){
    if (i == 5)
        continue;
    System.out.println(i);
}
```

В этом случае, когда выполнение цикла дойдет до числа 5, программа просто пропустит это число и перейдет к следующему.

## Массивы
Массив представляет набор однотипных значений. Объявление массива похоже на объявление обычной переменной, которая хранит одиночное значение, причем есть два способа объявления массива:
```java
тип_данных название_массива[];
// либо
тип_данных[] название_массива;
```

Например, определим массив чисел:
```java
int nums[];
int[] nums2;
```

*Java* поддерживает оба варианта синтаксиса, но рекомендуемый способ написания - `type[] name`. Так как скобки написаны рядом с типом, гораздо быстрее происходит понимание, что тип - массив, в противном случае приходится искать их уже у названия переменной.

После объявления массива мы можем инициализовать его:
```java
int[] nums;
nums = new int[4];  // массив из 4 чисел
```

Создание массива производится с помощью следующей конструкции: `new тип_данных[количество_элементов]`, где `new` - ключевое слово, *выделяющее память* для указанного в скобках количества элементов. Например, `nums = new int[4];` - в этом выражении создается массив из четырех элементов `int`, и каждый элемент будет иметь значение по умолчанию - число 0.

Массивы являются **ссылочными типами**, поэтому требуют выделения памяти в куче при помощи оператора `new`. Массивы являются объектами (пусть и специального рода).

Также можно сразу при объявлении массива инициализировать его:
```java
int nums[] = new int[4];    // массив из 4 чисел
int[] nums2 = new int[5];   // массив из 5 чисел
```

При подобной инициализации все элементы массива имеют значение по умолчанию. Для числовых типов (в том числе для типа `char`) это число 0, для типа `boolean` это значение `false`, а для остальных объектов это значение `null`. Например, для типа `int` значением по умолчанию является число 0, поэтому выше определенный массив `nums` будет состоять из четырех нулей.

Однако также можно задать конкретные значения для элементов массива при его создании:
```java
// эти два способа равноценны
int[] nums = new int[] { 1, 2, 3, 5 };
int[] nums2 = { 1, 2, 3, 5 };
```

Стоит отметить, что в этом случае в квадратных скобках не указывается размер массива, так как он вычисляется по количеству элементов в фигурных скобках.

После создания массива мы можем обратиться к любому его элементу по индексу, который передается в квадратных скобках после названия переменной массива:
```java
int[] nums = new int[4];
// устанавливаем значения элементов массива
nums[0] = 1;
nums[1] = 2;
nums[2] = 4;
nums[3] = 100;
         
// получаем значение третьего элемента массива
System.out.println(nums[2]);    // 4
```

Индексация элементов массива начинается с 0, поэтому в данном случае, чтобы обратиться к четвертому элементу в массиве, нам надо использовать выражение `nums[3]`.

И так как у нас массив определен только для 4 элементов, то мы не можем обратиться, например, к шестому элементу: `nums[5] = 5;`. Если мы так попытаемся сделать, то мы получим ошибку.

![Рисунок 1. Устройство массивов в памяти](../assets/images/ПБПОИ/shared/java-arrays-diagram.jpg)

*Рисунок 1. Устройство массивов в памяти*

Обратите внимание, что элементы расположены в памяти *последовательно*, индексы начинаются с нуля. В памяти ссылка на массив всегда указывает на первый элемент массива, а индекс `n` означает смещение на `n` размеров элементов массива. 

Например, если задан массив типа `int[] a` и индекс `n`, то `a[0]` будет указывать на адрес начала массива `a`, так как происходит 0 смещений. Выражение `a[3]` помогает получить значение ячейки памяти, смещенной на $3 * size_{int} = 3*4 = 12$ байт от начала массива. 

Собственно, так как индекс - это смещение, массивы и считаются с нуля, а обращение по тому индексу, которого нет в массиве, равносильно попытке обратиться к ячейке памяти, недоступной массиву(и не являющейся его частью), что приводит к ошибке.

### Длина массива
Важнейшее свойство, которым обладают массивы, является свойство `length`, возвращающее длину массива, то есть количество его элементов:
```java
int[] nums = {1, 2, 3, 4, 5};
int length = nums.length;   // 5
```

Нередко бывает неизвестным последний индекс, и чтобы получить последний элемент массива, мы можем использовать это свойство:
```java
int last = nums[nums.length-1];
```

### Многомерные массивы
Ранее мы рассматривали одномерные массивы, которые можно представить как цепочку или строку однотипных значений. Но кроме одномерных массивов также бывают и многомерными. Наиболее известный многомерный массив - таблица, представляющая двухмерный массив:
```java
int[] nums1 = new int[] { 0, 1, 2, 3, 4, 5 };
 
int[][] nums2 = { { 0, 1, 2 }, { 3, 4, 5 } };
```

Визуально оба массива можно представить следующим образом:

![Рисунок 2. Одномерные и многомерные массивы](../assets/images/ПБПОИ/shared/arrays.png)

*Рисунок 2. Одномерные и многомерные массивы*

Проще говоря, многомерный массив - это массив, состоящий из массивов. Каждый элемент массива (хранящийся в куче) хранит ссылку на свой внутренний массив (также хранящийся в куче).

Поскольку массив `nums2` двухмерный, он представляет собой простую таблицу. Его также можно было создать следующим образом: `int[][] nums2 = new int[2][3];`. Количество квадратных скобок указывает на размерность массива. А числа в скобках - на количество строк и столбцов. И также, используя индексы, мы можем использовать элементы массива в программе:
```java
// установим элемент первого столбца второй строки
nums2[1][0] = 44;
System.out.println(nums2[1][0]);
```

Объявление трехмерного массива могло бы выглядеть так:
```java
int[][][] nums3 = new int[2][3][4];
```

### Массив "лесенкой"
Многомерные массивы могут быть также представлены как *"зубчатые массивы"* или *"массивы лесенкой"*. В вышеприведенном примере двухмерный массив имел 3 строчки и три столбца, поэтому у нас получалась ровная таблица. Но мы можем каждому элементу в двухмерном массиве присвоить отдельный массив с различным количеством элементов:
```java
int[][] nums = new int[3][];
nums[0] = new int[2];
nums[1] = new int[3];
nums[2] = new int[5];
```
